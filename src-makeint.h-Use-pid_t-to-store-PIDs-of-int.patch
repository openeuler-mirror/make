From 3f194b69e37c93a3b5c3e1a5475a5514e71b43cb Mon Sep 17 00:00:00 2001
From: Aron Barath <baratharon@caesar.elte.hu>
Date: Mon, 9 Jul 2018 07:31:25 +0200
Subject: [PATCH 082/104] * src/makeint.h: Use pid_t to store PIDs, of int.

* src/commands.c (getpid): Ditto.
* src/job.h (*): Ditto.
* src/job.c (*): Ditto.
* src/main.c (main): Ditto.
* src/remote-cstms.c (start_remote_job): Ditto.
* src/remote-stub.c (start_remote_job): Ditto.
---
 commands.c     |  2 +-
 job.c          | 15 ++++++++-------
 job.h          |  2 +-
 main.c         |  2 +-
 makeint.h      |  2 +-
 remote-cstms.c |  4 ++--
 remote-stub.c  |  2 +-
 7 files changed, 15 insertions(+), 14 deletions(-)

--- a/commands.c	2019-04-10 22:47:44.401814695 -0400
+++ b/commands.c	2019-04-10 22:50:51.317814695 -0400
@@ -32,7 +32,7 @@ this program.  If not, see <http://www.g
 #endif
 
 #ifndef HAVE_UNISTD_H
-int getpid ();
+pid_t getpid ();
 #endif
 
 
--- a/job.c	2019-04-10 22:47:44.413814695 -0400
+++ b/job.c	2019-04-10 22:50:51.306814695 -0400
@@ -1340,7 +1340,8 @@ start_job_command (struct child *child)
   /* start_waiting_job has set CHILD->remote if we can start a remote job.  */
   if (child->remote)
     {
-      int is_remote, id, used_stdin;
+      int is_remote, used_stdin;
+      pid_t id;
       if (start_remote_job (argv, child->environment,
                             child->good_stdin ? 0 : get_bad_stdin (),
                             &is_remote, &id, &used_stdin))
@@ -2017,10 +2018,10 @@ start_waiting_jobs (void)
 
 /* EMX: Start a child process. This function returns the new pid.  */
 # if defined __EMX__
-int
+pid_t
 child_execute_job (struct output *out, int good_stdin, char **argv, char **envp)
 {
-  int pid;
+  pid_t pid;
   int fdin = good_stdin ? FD_STDIN : get_bad_stdin ();
   int fdout = FD_STDOUT;
   int fderr = FD_STDERR;
@@ -2115,11 +2116,11 @@ child_execute_job (struct output *out, i
 /* POSIX:
    Create a child process executing the command in ARGV.
    ENVP is the environment of the new program.  Returns the PID or -1.  */
-int
+pid_t
 child_execute_job (struct output *out, int good_stdin, char **argv, char **envp)
 {
   int r;
-  int pid;
+  pid_t pid;
   int fdin = good_stdin ? FD_STDIN : get_bad_stdin ();
   int fdout = FD_STDOUT;
   int fderr = FD_STDERR;
@@ -2167,7 +2168,7 @@ child_execute_job (struct output *out, i
 
 /* EMX: This function returns the pid of the child process.  */
 # ifdef __EMX__
-int
+pid_t
 # else
 void
 # endif
@@ -2243,7 +2244,7 @@ exec_command (char **argv, char **envp)
 #else  /* !WINDOWS32 */
 
 # ifdef __EMX__
-  int pid;
+  pid_t pid;
 # endif
 
   /* Be the user, permanently.  */
--- a/job.h	2019-04-10 22:47:44.386814695 -0400
+++ b/job.h	2019-04-10 22:50:51.319814695 -0400
@@ -131,7 +131,7 @@ int child_execute_job (struct child *chi
 # define FD_STDIN       (fileno (stdin))
 # define FD_STDOUT      (fileno (stdout))
 # define FD_STDERR      (fileno (stderr))
-int child_execute_job (struct output *out, int good_stdin, char **argv, char **envp);
+pid_t child_execute_job (struct output *out, int good_stdin, char **argv, char **envp);
 #endif
 
 #ifdef _AMIGA
--- a/main.c	2019-04-10 22:47:44.393814695 -0400
+++ b/main.c	2019-04-10 22:50:51.290814695 -0400
@@ -2457,7 +2457,7 @@ main (int argc, char **argv, char **envp
                Therefore it may be the best solution simply to spawn the
                child process including all file handles and to wait for its
                termination. */
-            int pid;
+	     pid_t pid;
             int r;
             pid = child_execute_job (NULL, 1, nargv, environ);
 
--- a/makeint.h	2019-04-10 22:47:44.413814695 -0400
+++ b/makeint.h	2019-04-10 22:50:51.297814695 -0400
@@ -705,7 +705,7 @@ vms_restore_symbol (const char *string);
 void remote_setup (void);
 void remote_cleanup (void);
 int start_remote_job_p (int);
-int start_remote_job (char **, char **, int, int *, int *, int *);
+int start_remote_job (char **, char **, int, int *, pid_t *, int *);
 int remote_status (int *, int *, int *, int);
 void block_remote_children (void);
 void unblock_remote_children (void);
--- b/remote-cstms.c	2019-04-10 22:47:44.413814695 -0400
+++ a/remote-cstms.c	2019-04-10 22:50:51.319814695 -0400
@@ -136,7 +136,7 @@ start_remote_job_p (int first_p)
 
 int
 start_remote_job (char **argv, char **envp, int stdin_fd,
-                  int *is_remote, int *id_ptr, int *used_stdin)
+		   int *is_remote, pid_t *id_ptr, int *used_stdin)
 {
   char waybill[MAX_DATA_SIZE], msg[128];
   struct hostent *host;
@@ -145,7 +145,7 @@ start_remote_job (char **argv, char **en
   int len;
   int retsock, retport, sock;
   Rpc_Stat status;
-  int pid;
+  pid_t pid;
 
   /* Create the return socket.  */
   retsock = Rpc_UdpCreate (True, 0);
--- a/remote-stub.c	2019-04-10 22:47:44.401814695 -0400
+++ b/remote-stub.c	2019-04-10 22:50:51.319814695 -0400
@@ -53,7 +53,7 @@ start_remote_job_p (int first_p UNUSED)
 
 int
 start_remote_job (char **argv UNUSED, char **envp UNUSED, int stdin_fd UNUSED,
-                  int *is_remote UNUSED, int *id_ptr UNUSED,
+		   int *is_remote UNUSED, pid_t *id_ptr UNUSED,
                   int *used_stdin UNUSED)
 {
   return -1;
